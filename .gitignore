#!/usr/bin/env python3
# File Integrity Checker (CLI)
# Internship Task - 1

import argparse
import hashlib
import json
import os
import sys
import time
from pathlib import Path
from typing import Dict, Tuple

CHUNK_SIZE = 1024 * 1024  # 1 MB


def compute_hash(path: Path, algo: str = "sha256") -> str:
    """Compute hash of a file, reading in chunks."""
    h = hashlib.new(algo)
    with path.open("rb") as f:
        while True:
            chunk = f.read(CHUNK_SIZE)
            if not chunk:
                break
            h.update(chunk)
    return h.hexdigest()


def scan_directory(base_dir: Path, recursive: bool = True, algo: str = "sha256") -> Dict[str, dict]:
    """
    Scan directory and return dict:
    relative_path -> {hash, size, mtime}
    """
    base_dir = base_dir.resolve()
    result = {}

    walker = base_dir.rglob("*") if recursive else base_dir.glob("*")

    for p in walker:
        if p.is_file():
            try:
                rel = str(p.relative_to(base_dir))
                stat = p.stat()
                h = compute_hash(p, algo)
                result[rel] = {
                    "hash": h,
                    "size": stat.st_size,
                    "mtime": stat.st_mtime,
                }
            except (PermissionError, OSError) as e:
                result[str(p.relative_to(base_dir))] = {
                    "error": f"{type(e).__name__}: {e}"
                }

    return result


def load_baseline(baseline_path: Path) -> dict:
    with baseline_path.open("r", encoding="utf-8") as f:
        return json.load(f)


def save_baseline(baseline: dict, baseline_path: Path):
    with baseline_path.open("w", encoding="utf-8") as f:
        json.dump(baseline, f, indent=2, sort_keys=True)


def compare_baselines(old: dict, new: dict) -> Tuple[dict, dict, dict]:
    """Return added, deleted, modified"""
    old_keys = set(old.keys())
    new_keys = set(new.keys())

    added = {k: new[k] for k in new_keys - old_keys}
    deleted = {k: old[k] for k in old_keys - new_keys}
    modified = {}

    for k in old_keys & new_keys:
        old_entry = old[k]
        new_entry = new[k]

        if old_entry.get("hash") != new_entry.get("hash"):
            modified[k] = {"old": old_entry, "new": new_entry}

    return added, deleted, modified


def pretty_print_diff(added, deleted, modified):
    if not (added or deleted or modified):
        print("[+] No changes detected.")
        return

    if added:
        print(f"\n[+] Added files ({len(added)}):")
        for k in added:
            print("  +", k)

    if deleted:
        print(f"\n[-] Deleted files ({len(deleted)}):")
        for k in deleted:
            print("  -", k)

    if modified:
        print(f"\n[!] Modified files ({len(modified)}):")
        for k, info in modified.items():
            print("  *", k)
            print("     old hash:", info["old"].get("hash"))
            print("     new hash:", info["new"].get("hash"))


def cmd_init(args):
    target = Path(args.target)

    if not target.exists():
        print("Error: target path does not exist", file=sys.stderr)
        sys.exit(1)

    print(f"[+] Scanning {target} (recursive={args.recursive}) using {args.algo}")
    files = scan_directory(target, args.recursive, args.algo)

    baseline = {
        "_meta": {
            "base_dir": str(target.resolve()),
            "created_at": time.time(),
            "algo": args.algo,
            "recursive": args.recursive,
        },
        "files": files,
    }

    save_baseline(baseline, Path(args.baseline))
    print(f"[+] Baseline saved to {args.baseline} ({len(files)} files)")


def cmd_check(args):
    baseline_path = Path(args.baseline)

    if not baseline_path.exists():
        print("Error: baseline not found", file=sys.stderr)
        sys.exit(1)

    baseline = load_baseline(baseline_path)
    meta = baseline["_meta"]
    files = baseline["files"]

    base_dir = Path(meta["base_dir"])
    algo = meta["algo"]
    recursive = meta["recursive"]

    print("[+] Checking baseline")
    new_files = scan_directory(base_dir, recursive, algo)

    added, deleted, modified = compare_baselines(files, new_files)
    pretty_print_diff(added, deleted, modified)

    sys.exit(2 if (added or deleted or modified) else 0)


def cmd_monitor(args):
    baseline_path = Path(args.baseline)
    baseline = load_baseline(baseline_path)

    meta = baseline["_meta"]
    files = baseline["files"]

    base_dir = Path(meta["base_dir"])
    algo = meta["algo"]
    recursive = meta["recursive"]

    print(f"[+] Monitoring {base_dir} every {args.interval} seconds (Ctrl+C to stop)")

    try:
        while True:
            new_files = scan_directory(base_dir, recursive, algo)
            added, deleted, modified = compare_baselines(files, new_files)

            if added or deleted or modified:
                print("\n[!] Changes detected:")
                pretty_print_diff(added, deleted, modified)

                if args.update:
                    baseline["files"] = new_files
                    baseline["_meta"]["updated_at"] = time.time()
                    save_baseline(baseline, baseline_path)
                    files = new_files
                    print("[+] Baseline updated")

            else:
                print(".", end="", flush=True)

            time.sleep(args.interval)

    except KeyboardInterrupt:
        print("\n[+] Monitoring stopped")


def build_parser():
    parser = argparse.ArgumentParser(description="File Integrity Checker")
    sub = parser.add_subparsers(dest="cmd", required=True)

    p_init = sub.add_parser("init", help="Create baseline")
    p_init.add_argument("target")
    p_init.add_argument("--baseline", default="baseline.json")
    p_init.add_argument("--algo", default="sha256")
    p_init.add_argument("--recursive", action="store_true")
    p_init.set_defaults(func=cmd_init)

    p_check = sub.add_parser("check", help="Check baseline")
    p_check.add_argument("baseline")
    p_check.set_defaults(func=cmd_check)

    p_monitor = sub.add_parser("monitor", help="Monitor continuously")
    p_monitor.add_argument("baseline")
    p_monitor.add_argument("--interval", type=int, default=60)
    p_monitor.add_argument("--update", action="store_true")
    p_monitor.set_defaults(func=cmd_monitor)

    return parser


def main():
    parser = build_parser()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
